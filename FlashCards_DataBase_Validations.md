## Associations & Validations

### What method can you call on one of your models' instance to check its validity?

You can call `.valid?` on it. It will return `false` if it's not.Then, you can call `.errors.messages` to know why it's invalid

### What are the 3 steps you should follow to properly modelize your data when conceiving your app?

1. Draw the tables in [db.lewagon.org](http://db.lewagon.org/)
2. Create the migrations
3. Create the models

Don't forget to strictly follow ActiveRecord's naming convention (table name `lower_case` plural, model name `CamelCase` singular)!

### What happens when you try to `#save` an invalid record?

Transaction with DB will rollback and `.save` will return false:

```Ruby
restaurant = Restaurant.new(name: "La Tour d'Argent")
restaurant.save
# (0.1ms)  begin transaction
# (0.1ms)  rollback transaction
# => false
```

It will return `true` if the instance is valid and transaction was properly committed to the DB.If you want your code to raise an Exception on an invalid record's saving attempt, you should call `#save!

```Ruby
class Doctor < ActiveRecord::Base
  has_many :interns
end
```

Note the plural form in `:interns`, a doctor having **many** interns.

You can now call `.interns` on an instance of `Doctor` in ruby to retrieve its interns in an array.

```Ruby
class Intern < ActiveRecord::Base
  belongs_to :doctor
end
```

Note the singular form in `:doctor`, an intern belonging to **one** doctor.

You can now call `.doctor` on an instance of `Intern` in ruby to retrieve its referent doctor (as an object).

### Remove / Add / Rename column from table

```Ruby
class RemoveColumnFromTable < ActiveRecord::Migration[5.1]
  def change
    add_column :table, :column_name, :data_type(string,integer...)
    remove_column :table, :column
    rename_column :table, :old_column_name, :new_column_name
  end
end
```

### 1:N create table

```Ruby
def change
    create_table :interns do |t|
      t.string      :first_name
      t.string      :last_name
      t.references  :doctor, foreign_key: true 
        # create a column doctor_in in interns table
      t.timestamps
    end
  end
#Note the t.references to store the foreign key, taking :doctor as an argument and not :doctor_id.
```

### Validates

Adding validations to your model guarantees you won't persist data you consider invalid in your database. At each `#save` call on an instance of your model, your validations will be checked.

```Ruby
validates :github_nickname, presence: true, uniqueness: true
validates :email, format: { with: /\A.*@.*\.com\z/ }
validates :description, length: { minimum: 120 }
# mostly checked validations => Presence, uniqueness (stand alone or using a scope), length (min or max), format (using Regexp).
```

### N:N relations need to ADD a join table

```Ruby
class CreateCategoriesPosts < ActiveRecord::Migration[5.1]
  def change
    create_table :categories_posts do |t|
      t.references :post, foreign_key: true
      t.references :category, foreign_key: true
      t.timestamps
    end
  end
end
```

And using `through` in your associations instructions in your models classes:

```Ruby
class Post < ActiveRecord::Base
  has_many :categories_posts
  has_many :categories, through: :categories_posts
end
```

```Ruby
class Category < ActiveRecord::Base
  has_many :categories_posts
  has_many :posts, through: :categories_posts
end
```

And don't forget to add the `belongs_to` in the new `CategoriesPost` model:

```Ruby
class CategoriesPost < ActiveRecord::Base
  belongs_to :category
  belongs_to :post
end
```

### What is the SQL query generated by `#save` in the following context:

Note that every ActiveRecord query generates an SQL query that you can read in your application logs in your terminal!

```Ruby
doctor = Doctor.new(name: "Greg House", specialty: "Rare Diseases")
doctor.save
INSERT INTO doctors (name, specialty) VALUES ('Greg House', 'Rare Diseases');
```

### Destroy all

To delete all instances of a given model you can call `.destroy_all` on your model: Restaurant.destroy_all

### Write the migration to add an `intern_id` foreign key in `patients` table

```Ruby
class AddInternReferenceToPatients < ActiveRecord::Migration[5.1]
  def change
    add_reference :patients, :intern, foreign_key: true
  end
end
```

Note the second argument `:intern` and not `:intern_id`!

It will result anyway in an `intern_id` column in your database, but lets you think object-wise in ruby!

